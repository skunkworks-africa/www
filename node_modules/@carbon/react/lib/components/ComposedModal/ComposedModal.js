/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var reactIs = require('react-is');
var PropTypes = require('prop-types');
var ModalHeader = require('./ModalHeader.js');
var ModalFooter = require('./ModalFooter.js');
var debounce = require('lodash.debounce');
var useIsomorphicEffect = require('../../internal/useIsomorphicEffect.js');
var mergeRefs = require('../../tools/mergeRefs.js');
var cx = require('classnames');
var toggleClass = require('../../tools/toggleClass.js');
var requiredIfGivenPropIsTruthy = require('../../prop-types/requiredIfGivenPropIsTruthy.js');
var wrapFocus = require('../../internal/wrapFocus.js');
var usePrefix = require('../../internal/usePrefix.js');
var index = require('../FeatureFlags/index.js');
var match = require('../../internal/keyboard/match.js');
var keys = require('../../internal/keyboard/keys.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);

const ModalBody = /*#__PURE__*/React__default["default"].forwardRef(function ModalBody(_ref, ref) {
  let {
    className: customClassName,
    children,
    hasForm,
    hasScrollingContent,
    ...rest
  } = _ref;
  const prefix = usePrefix.usePrefix();
  const contentRef = React.useRef(null);
  const [isScrollable, setIsScrollable] = React.useState(false);
  const contentClass = cx__default["default"]({
    [`${prefix}--modal-content`]: true,
    [`${prefix}--modal-content--with-form`]: hasForm,
    [`${prefix}--modal-scroll-content`]: hasScrollingContent || isScrollable
  }, customClassName);
  useIsomorphicEffect["default"](() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce__default["default"](handler, 200);
    window.addEventListener('resize', debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener('resize', debouncedHandler);
    };
  }, []);
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: 'region'
  } : {};
  return /*#__PURE__*/React__default["default"].createElement("div", _rollupPluginBabelHelpers["extends"]({
    className: contentClass
  }, hasScrollingContentProps, rest, {
    ref: mergeRefs["default"](contentRef, ref)
  }), children);
});
ModalBody.propTypes = {
  /**
   * Required props for the accessibility label of the header
   */
  ['aria-label']: requiredIfGivenPropIsTruthy["default"]('hasScrollingContent', PropTypes__default["default"].string),
  /**
   * Specify the content to be placed in the ModalBody
   */
  children: PropTypes__default["default"].node,
  /**
   * Specify an optional className to be added to the Modal Body node
   */
  className: PropTypes__default["default"].string,
  /**
   * Provide whether the modal content has a form element.
   * If `true` is used here, non-form child content should have `cds--modal-content__regular-content` class.
   */
  hasForm: PropTypes__default["default"].bool,
  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: PropTypes__default["default"].bool
};
const ComposedModal = /*#__PURE__*/React__default["default"].forwardRef(function ComposedModal(_ref2, ref) {
  let {
    ['aria-labelledby']: ariaLabelledBy,
    ['aria-label']: ariaLabel,
    children,
    className: customClassName,
    containerClassName,
    danger,
    isFullWidth,
    onClose,
    onKeyDown,
    open,
    preventCloseOnClickOutside,
    selectorPrimaryFocus = '[data-modal-primary-focus]',
    selectorsFloatingMenus,
    size,
    launcherButtonRef,
    slug,
    ...rest
  } = _ref2;
  const prefix = usePrefix.usePrefix();
  const [isOpen, setIsOpen] = React.useState(!!open);
  const [wasOpen, setWasOpen] = React.useState(!!open);
  const innerModal = React.useRef(null);
  const button = React.useRef(null);
  const startSentinel = React.useRef(null);
  const endSentinel = React.useRef(null);
  const focusTrapWithoutSentinels = index.useFeatureFlag('enable-experimental-focus-wrap-without-sentinels');

  // Keep track of modal open/close state
  // and propagate it to the document.body
  React.useEffect(() => {
    if (open !== wasOpen) {
      setIsOpen(!!open);
      setWasOpen(!!open);
      toggleClass["default"](document.body, `${prefix}--body--with-modal-open`, !!open);
    }
  }, [open, wasOpen, prefix]);
  // Remove the document.body className on unmount
  React.useEffect(() => {
    return () => {
      toggleClass["default"](document.body, `${prefix}--body--with-modal-open`, false);
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  function handleKeyDown(event) {
    event.stopPropagation();
    if (match.match(event, keys.Escape)) {
      closeModal(event);
    }
    if (focusTrapWithoutSentinels && open && match.match(event, keys.Tab) && innerModal.current) {
      wrapFocus.wrapFocusWithoutSentinels({
        containerNode: innerModal.current,
        currentActiveNode: event.target,
        event: event
      });
    }
    onKeyDown?.(event);
  }
  function handleMousedown(evt) {
    const target = evt.target;
    evt.stopPropagation();
    if (!preventCloseOnClickOutside && !wrapFocus.elementOrParentIsFloatingMenu(target, selectorsFloatingMenus) && innerModal.current && !innerModal.current.contains(target)) {
      closeModal(evt);
    }
  }
  function handleBlur(_ref3) {
    let {
      target: oldActiveNode,
      relatedTarget: currentActiveNode
    } = _ref3;
    if (open && currentActiveNode && oldActiveNode && innerModal.current) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startSentinelNode
      } = startSentinel;
      const {
        current: endSentinelNode
      } = endSentinel;
      wrapFocus["default"]({
        bodyNode,
        startTrapNode: startSentinelNode,
        endTrapNode: endSentinelNode,
        currentActiveNode,
        oldActiveNode,
        selectorsFloatingMenus: selectorsFloatingMenus?.filter(Boolean)
      });
    }
  }
  function closeModal(evt) {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  }
  const modalClass = cx__default["default"](`${prefix}--modal`, {
    'is-visible': isOpen,
    [`${prefix}--modal--danger`]: danger,
    [`${prefix}--modal--slug`]: slug
  }, customClassName);
  const containerClass = cx__default["default"](`${prefix}--modal-container`, size && `${prefix}--modal-container--${size}`, isFullWidth && `${prefix}--modal-container--full-width`, containerClassName);

  // Generate aria-label based on Modal Header label if one is not provided (L253)
  let generatedAriaLabel;
  const childrenWithProps = React__default["default"].Children.toArray(children).map(child => {
    switch (true) {
      case reactIs.isElement(child) && child.type === React__default["default"].createElement(ModalHeader.ModalHeader).type:
        {
          const el = child;
          generatedAriaLabel = el.props.label;
          return /*#__PURE__*/React__default["default"].cloneElement(el, {
            closeModal
          });
        }
      case reactIs.isElement(child) && child.type === React__default["default"].createElement(ModalFooter.ModalFooter).type:
        {
          const el = child;
          return /*#__PURE__*/React__default["default"].cloneElement(el, {
            closeModal,
            inputref: button
          });
        }
      default:
        return child;
    }
  });
  React.useEffect(() => {
    if (!open && launcherButtonRef) {
      setTimeout(() => {
        launcherButtonRef?.current?.focus();
      });
    }
  }, [open, launcherButtonRef]);
  React.useEffect(() => {
    const initialFocus = focusContainerElement => {
      const containerElement = focusContainerElement || innerModal.current;
      const primaryFocusElement = containerElement ? containerElement.querySelector(selectorPrimaryFocus) : null;
      if (primaryFocusElement) {
        return primaryFocusElement;
      }
      return button && button.current;
    };
    const focusButton = focusContainerElement => {
      const target = initialFocus(focusContainerElement);
      if (target) {
        target.focus();
      }
    };
    if (open && isOpen) {
      focusButton(innerModal.current);
    }
  }, [open, selectorPrimaryFocus, isOpen]);

  // Slug is always size `sm`
  let normalizedSlug;
  if (slug && slug['type']?.displayName === 'Slug') {
    normalizedSlug = /*#__PURE__*/React__default["default"].cloneElement(slug, {
      size: 'sm'
    });
  }
  return /*#__PURE__*/React__default["default"].createElement("div", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "presentation",
    ref: ref,
    "aria-hidden": !open,
    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {},
    onMouseDown: handleMousedown,
    onKeyDown: handleKeyDown,
    className: modalClass
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: containerClass,
    role: "dialog",
    "aria-modal": "true",
    "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
    "aria-labelledby": ariaLabelledBy
  }, !focusTrapWithoutSentinels && /*#__PURE__*/React__default["default"].createElement("button", {
    type: "button",
    ref: startSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), /*#__PURE__*/React__default["default"].createElement("div", {
    ref: innerModal,
    className: `${prefix}--modal-container-body`
  }, normalizedSlug, childrenWithProps), !focusTrapWithoutSentinels && /*#__PURE__*/React__default["default"].createElement("button", {
    type: "button",
    ref: endSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel")));
});
ComposedModal.propTypes = {
  /**
   * Specify the aria-label for cds--modal-container
   */
  ['aria-label']: PropTypes__default["default"].string,
  /**
   * Specify the aria-labelledby for cds--modal-container
   */
  ['aria-labelledby']: PropTypes__default["default"].string,
  /**
   * Specify the content to be placed in the ComposedModal
   */
  children: PropTypes__default["default"].node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: PropTypes__default["default"].string,
  /**
   * Specify an optional className to be applied to the modal node
   */
  containerClassName: PropTypes__default["default"].string,
  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: PropTypes__default["default"].bool,
  /**
   * Specify whether the Modal content should have any inner padding.
   */
  isFullWidth: PropTypes__default["default"].bool,
  /**
   * Provide a ref to return focus to once the modal is closed.
   */
  // @ts-expect-error: Invalid derived type
  launcherButtonRef: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
    current: PropTypes__default["default"].any
  })]),
  /**
   * Specify an optional handler for closing modal.
   * Returning `false` here prevents closing modal.
   */
  onClose: PropTypes__default["default"].func,
  /**
   * Specify an optional handler for the `onKeyDown` event. Called for all
   * `onKeyDown` events that do not close the modal
   */
  onKeyDown: PropTypes__default["default"].func,
  /**
   * Specify whether the Modal is currently open
   */
  open: PropTypes__default["default"].bool,
  preventCloseOnClickOutside: PropTypes__default["default"].bool,
  /**
   * Specify a CSS selector that matches the DOM element that should be
   * focused when the Modal opens
   */
  selectorPrimaryFocus: PropTypes__default["default"].string,
  /**
   * Specify the CSS selectors that match the floating menus
   */
  selectorsFloatingMenus: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string.isRequired),
  /**
   * Specify the size variant.
   */
  size: PropTypes__default["default"].oneOf(['xs', 'sm', 'md', 'lg']),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `ComposedModal` component
   */
  slug: PropTypes__default["default"].node
};

exports.ModalBody = ModalBody;
exports["default"] = ComposedModal;
